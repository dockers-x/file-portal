<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Upload • <%= brandTitle %></title>
  <link rel="icon" href="/static/favicon.svg" type="image/svg+xml"/>
  <link rel="stylesheet" href="/static/styles.css"/>
  <% if (brandPrimary) { %><style>:root{ --primary:<%= brandPrimary %>; }</style><% } %>
</head>
<body>
  <div class="card" style="max-width: 980px; margin: 40px auto;">
    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px">
      <h2 style="margin:0">Upload Files</h2>
      <button id="btnDone" class="btn btn-primary" type="button">Done</button>
    </div>
    <div id="zone" style="border:2px dashed #93c5fd; padding:20px; border-radius:12px; text-align:center;">
      <p>Drag and Drop Files or <button id="btnBrowse" class="btn btn-blue" type="button">Browse</button></p>
      <input id="picker" type="file" multiple style="display:none"/>
    </div>
    <div id="queue" style="margin-top:16px"></div>
    <div style="display:flex; gap:10px; margin-top:10px;">
      <button id="btnStart" class="btn btn-primary" style="display:none">Upload</button>
      <button id="btnCancel" class="btn btn-muted" disabled>Cancel</button>
    </div>
  </div>

<script>
const PARALLEL = <%= parallel %>;
function toast(msg, type='info', ms=8000){ let w=document.querySelector('.toast-wrap'); if(!w){ w=document.createElement('div'); w.className='toast-wrap'; document.body.appendChild(w);} const t=document.createElement('div'); t.className='toast '+(type==='ok'?'ok':type==='err'?'err':'info'); t.textContent=msg; w.appendChild(t); setTimeout(()=>{ t.style.opacity='0'; t.style.transform='translateY(-4px)'; }, Math.max(2600, ms-600)); setTimeout(()=>{ try{ w.removeChild(t);}catch{} }, ms); }
document.addEventListener('DOMContentLoaded', ()=>{ const done = document.getElementById('btnDone'); if (done){ done.addEventListener('click', ()=>{ window.location.assign('/dashboard'); }); } });

const workerCode = () => { self.onmessage = async (e)=>{ const file = e.data; try{ const buf = await file.arrayBuffer(); const hashBuf = await crypto.subtle.digest('SHA-256', buf); const hashArr = Array.from(new Uint8Array(hashBuf)).map(b=>b.toString(16).padStart(2,'0')).join(''); self.postMessage({ok:true, hash: hashArr}); }catch(err){ self.postMessage({ok:false}); } }; };
const workerBlob = new Blob([ '(' + workerCode.toString() + ')()' ], { type: 'application/javascript' });
const hasher = new Worker(URL.createObjectURL(workerBlob));
function hashFile(file){ return new Promise(res=>{ const onm = (ev)=>{ res(ev.data.ok ? ev.data.hash : null); hasher.removeEventListener('message', onm); }; hasher.addEventListener('message', onm); hasher.postMessage(file); }); }

const zone = document.getElementById('zone');
const picker = document.getElementById('picker');
const btnBrowse = document.getElementById('btnBrowse');
const btnCancel = document.getElementById('btnCancel');
const btnDone = document.getElementById('btnDone');
const queue = document.getElementById('queue');

let q = []; // queue
let uploading = false;
const uploadedNames = new Set();
const uploadedHashes = new Set();

btnBrowse.onclick = () => picker.click();
picker.onchange = () => addFiles(Array.from(picker.files));

zone.ondragover = (e)=>{ e.preventDefault(); zone.style.filter='brightness(1.05)'; };
zone.ondragleave = ()=>{ zone.style.filter=''; };
zone.ondrop = (e)=>{ e.preventDefault(); zone.style.filter=''; addFiles(Array.from(e.dataTransfer.files)); };

function human(n){ const u=['B','KB','MB','GB','TB']; let i=0,v=n; while(v>=1024 && i<u.length-1){ v/=1024; i++; } return (Math.round(v*10)/10)+' '+u[i]; }

async function addFiles(files){
  for (const file of files){
    if (uploadedNames.has(file.name)) { toast('Skipped (already uploaded by name): ' + file.name, 'info'); continue; }
    const h = await hashFile(file);
    if (h && uploadedHashes.has(h)) { toast('Skipped (already uploaded by content): ' + file.name, 'info'); continue; }

    const row = document.createElement('div');
    row.style.cssText='background:#fff; border:1px solid #eef0f5; border-radius:12px; padding:10px 12px; margin:10px 0;';
    row.innerHTML = `<div style="display:flex;align-items:center;justify-content:space-between;gap:10px;"><div style="font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:260px;" title="${file.name}">${file.name}</div><div style="font-size:12px;color:#6b7280">${human(file.size)}</div></div><div style="height:10px;background:#e5e7eb;border-radius:8px;overflow:hidden;margin-top:8px"><div class="bar" style="height:100%;width:0%;background:linear-gradient(90deg,#60a5fa,#93c5fd)"></div></div><div style="font-size:12px;color:#6b7280"><span class="pct">0%</span> • <span class="spd">0 KB/s</span></div><div class="q-links" style="margin-top:6px; display:none; gap:6px"><button class="btn btn-muted small copylink">Copy Link</button></div>`;
    const obj = { file, el: row, lastT: Date.now(), lastLoaded:0, xhr:null, fileId:null, hash:h };
    queue.appendChild(row); q.push(obj);
  }
  startUploads();
}

btnCancel.onclick = ()=>{
  if (!uploading) return;
  q.filter(x=>x.xhr).forEach(x=>{ try{ x.xhr.abort(); }catch{} });
  toast('Upload canceled','err', 8000);
};

function setDisabled(d){
  if (btnBrowse) btnBrowse.disabled = d;
  if (picker) picker.disabled = d;
  if (btnDone) btnDone.disabled = d;
}

async function startUploads(){
  if (uploading || !q.length) return;
  uploading = true; setDisabled(true); btnCancel.disabled = false;

  const uploadItem = (item) => new Promise((resolve)=>{
    const fd = new FormData();
    fd.append('files', item.file);

    const xhr = new XMLHttpRequest(); item.xhr = xhr;
    const bar = item.el.querySelector('.bar');
    const pct = item.el.querySelector('.pct');
    const spd = item.el.querySelector('.spd');
    const links = item.el.querySelector('.q-links');
    const copyBtn = item.el.querySelector('.copylink');

    xhr.open('POST','/api/upload', true);
    xhr.upload.onprogress = (e)=>{
      if (e.lengthComputable){
        const percent = Math.round((e.loaded/e.total)*100);
        bar.style.width = percent + '%'; pct.textContent = percent + '%';
        const now = Date.now(), dt = (now - item.lastT)/1000;
        if (dt > 0.2){ const speed = (e.loaded - item.lastLoaded) / dt; spd.textContent = human(speed) + '/s'; item.lastT = now; item.lastLoaded = e.loaded; }
      }
    };
    xhr.onreadystatechange = async ()=>{
      if (xhr.readyState===4){
        item.xhr = null;
        if (xhr.status>=200 && xhr.status<300){
          try {
            const j = JSON.parse(xhr.responseText);
            if (j.ok && j.saved && j.saved.length){
              const id = j.saved[0].id;
              uploadedNames.add(item.file.name);
              if (item.hash) uploadedHashes.add(item.hash);
              links.style.display='flex';
              copyBtn.onclick = async ()=>{
                const r = await fetch('/api/getlink',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id })});
                const g = await r.json();
                if (g.ok){ await navigator.clipboard.writeText(g.directUrl); toast('Download Link Copied for ' + item.file.name, 'ok', 8000); }
              };
            }
          }catch{ toast('Failed','err', 8000); }
        } else {
          spd.textContent = 'failed'; let msg = 'Upload failed';
          try { const err = JSON.parse(xhr.responseText); if (err && err.error) msg = 'Upload failed: ' + err.error; } catch {}
          toast(msg,'err', 8000);
        }
        resolve(true);
      }
    };
    xhr.send(fd);
  });

  let running = 0;
  const pump = ()=>{
    while (running < PARALLEL && q.length){
      const item = q.shift();
      running++;
      uploadItem(item).finally(()=>{
        running--;
        if (running===0 && q.length===0){
          uploading = false; setDisabled(false); btnCancel.disabled = true;
        }
        pump();
      });
    }
  };
  pump();
}
</script>
</body>
</html>
